<!doctype html>
<!--suppress JSUnresolvedReference -->
<html lang='en'>

<head>
    <title>OVE Core</title>
    <link rel='shortcut icon' href='#'>

    <link rel='stylesheet' href='./markdown-github.css'>
    <style>
        .markdown-body {
            background-color:white;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }

        .markdown-body table td, .markdown-body table th {
            border: none;
        }

        @media (max-width: 767px) {
            .markdown-body {
                padding: 15px;
            }
        }

        .dataTables_paginate, .dataTables_info, .dataTables_length {
            font-size: 12px;
        }

        .dataTables_length {
            padding-top: 0.5em;
        }

        .client {
            fill: lightgrey;
            stroke: black;
            stroke-width: 1px;
        }

        .section {
            stroke: none;
            opacity: 0.7;
            stroke-width: 0;
        }

        .section-label, .space-label {
            fill: white;
        }

    </style>

    <script src='https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.4/d3.min.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.js'></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/datatables/1.10.21/js/jquery.dataTables.min.js'></script>

    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/datatables/1.10.21/css/jquery.dataTables.min.css">
    <script>
        function getScaleForSpace(geometry, width, height) {
            // Pick a scale which will scale the bounding-box of the screens in this space to fit
            const xMax = d3.max(geometry.map(function (m) {
                return m.x + m.w;
            }));
            const yMax = d3.max(geometry.map(function (m) {
                return m.y + m.h;
            }));

            return Math.max((yMax / height), (xMax / width));
        }

        let space = "%%space%%";
        let spaces;
        let sections;

        function loadState() {
            $.fn.dataTable.ext.errMode = 'none';
            fetch("%%spaces%%").then(res => res.json()).then(data => {
                spaces = data;
                fetch("%%sections%%").then(res => res.json()).then(data => {
                    sections = data["Sections"].map((s, i) => ({...s, id: i}));
                    displayState();
                });
            });
        }
        function displayState() {
            if (spaces && sections) {
                drawSpaces(spaces, sections);
                tabulateSections(spaces, sections)
            }
        }

        function drawSpaces(spaces, sections) {
            const margin = 50;
            const width = Math.min(767, window.innerWidth - 2 * margin);
            const height = Math.min(767, window.innerHeight - 2 * margin);

            d3.selectAll('#spaces>div').remove();

            let spaceNames = Object.keys(spaces).filter(name => name === space);

            let scaleFactor = d3.max(spaceNames.map(name => getScaleForSpace(spaces[name], width, height)));

            let x = d3.scaleLinear().range([0, width]).domain([0, width * scaleFactor]);
            let y = d3.scaleLinear().range([0, height]).domain([0, height * scaleFactor]);

            let divs = d3.select('#spaces')
                .selectAll('div')
                .data(spaceNames)
                .enter()
                .append('div');

            divs.append('h3').html(d => `${d}`);

            // Create an SVG for each space, setting width and height separately
            let svgs = divs.append('svg')
                .attr('width', d => d3.max(spaces[d].map(m => x(m.x + m.w))))
                .attr('height', d => d3.max(spaces[d].map(m => y(m.y + m.h))));

            svgs.selectAll('rect')
                .data(d => spaces[d])
                .enter()
                .append('rect')
                .attr('x', d => x(d.x))
                .attr('y', d => y(d.y))
                .attr('width', d => x(d.w))
                .attr('height', d => x(d.h))
                .classed('client', true)
                .append('title')
                .text((d, i) => 'Client Id: ' + i);

            const minClientHeight = d3.min(Object.values(spaces).map(s => d3.min(s.map( d => x(d.h)))));
            const minClientWidth = d3.min(Object.values(spaces).map(s => d3.min(s.map( d => x(d.w)))));
            const clientTextSize = Math.min(minClientHeight, minClientWidth) / 4;
            svgs.selectAll('.space-label')
                .data(d => spaces[d])
                .enter()
                .append('text')
                .text((d,i) => i)
                .attr('x', d => (x((+d.x) + (+d.w)/2) - clientTextSize*0.25))
                .attr('y', d => (y((+d.y) + (+d.h)/2) + clientTextSize*0.5))
                .style('font-size', clientTextSize + 'px')
                .classed('space-label', true);

            const colors = ['dodgerblue', 'crimson', 'darkorange', 'darkviolet', '#4daf4a'];
            svgs.selectAll('.sections')
                .data(d => sections.filter(s => (s.space === d)))
                .enter()
                .append('rect')
                .attr('x', d => x(d.x))
                .attr('y', d => y(d.y))
                .attr('width', d => x(d.w))
                .attr('height', d => y(d.h))
                .style('fill', (d,i) => colors[i % colors.length])
                .classed('section', true)
                .append('title')
                .text(d => 'Section Id: ' + d.id);

            const minSectionHeight = d3.min(sections.map( d => x(d.h)));
            const minSectionWidth = d3.min(sections.map( d => x(d.w)));
            const sectionTextSize = Math.min(minSectionHeight, minSectionWidth) / 4;
            svgs.selectAll('.section-label')
                .data(d => sections.filter(s => (s.space === d)))
                .enter()
                .append('text')
                .text(d => d.id)
                .attr('x', d => (x((+d.x) + (+d.w)/2) - sectionTextSize*0.25))
                .attr('y', d => (y((+d.y) + (+d.h)/2) + sectionTextSize*0.5))
                .style('font-size', sectionTextSize + 'px')
                .classed('section-label', true);
        }

        function tabulateSections(spaces, sections){
            const appURLs = [...new Set(sections.map(d => !d.app ? '' : d.app.url))];
            let urlsToProcess = appURLs.length;
            let appNames = {};

            appURLs.map(url => {
                d3.json(url + '/name')
                    .then( name => {
                        appNames[url] = name.charAt(0).toUpperCase() + name.substring(1);
                        urlsToProcess--;

                        if (urlsToProcess === 0){
                            createSectionsTables(spaces, sections, appNames);
                        }
                    }, () => {
                        appNames[url] = url;
                        urlsToProcess--;

                        if (urlsToProcess === 0){
                            createSectionsTables(spaces, sections, appNames);
                        }
                    });
            });
        }

        function createSectionsTables(spaces, sections, appNames) {
            let spaceNames = Object.keys(spaces)
                .filter(space => sections.filter(section => (section.space === space)).length > 0);

            let divs = d3.select('#sections')
                .selectAll('div')
                .data(spaceNames)
                .enter();

            const blocks = divs.append('div');

            blocks.append('h3').text(d => d);

            const columns = ['Id', 'x', 'y', 'Width', 'Height', 'App'];

            const convert = d => [
                d.id,
                d.x,
                d.y,
                d.w,
                d.h,
                appNames[d.app.url]
            ];

            const tables = blocks.append('table')
                .attr('class', 'dataTable display cell-border no-footer')
                .attr('style', 'display:table')
                .attr('id', d => `section-table-${d}`);

            tables.append("thead")
                .selectAll("th")
                .data(columns)
                .enter("th")
                .text(d => d);
            tables.append("tbody");

            spaceNames.map(spaceName => {
                const values = sections.filter(s => (s.space === spaceName)).map(convert);

                $(`#section-table-${spaceName}`).DataTable({
                    data: values,
                    columns: columns.map(d => ({title: d}))
                });
            });
        }
    </script>

</head>
    <body class='markdown-body' onload='loadState()' onresize='loadState()'>
    <h2>Sections</h2>
    <div id='sections'></div>


    <h2>Space Layouts</h2>
    <div id='spaces'></div>

</body>

</html>